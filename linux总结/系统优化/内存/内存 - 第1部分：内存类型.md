# 内存 - 第1部分：内存类型

原文地址:[https://techtalk.intersec.com/2013/07/memory-part-1-memory-types/](https://techtalk.intersec.com/2013/07/memory-part-1-memory-types/)

[TOC]

# 介绍

在Intersec，我们选择了C编程语言，因为它使我们能够完全控制我们正在做的事情，并实现高水平的性能。对于许多人来说，性能只是使用尽可能少的CPU指令。但是，在现代硬件上，它比CPU复杂得多。算法必须处理内存，CPU，磁盘和网络I / O ......它们中的每一个都增加了算法的成本，并且必须正确理解它们中的每一个，以便保证算法的性能和可靠性。

CPU（以及因此算法复杂性）对性能的影响很容易理解，磁盘和网络延迟也是如此。然而记忆似乎不太了解。正如我们与客户的经验所表明的那样，即使是广泛使用的工具的输出，`top`对大多数系统管理员来说都是神秘的。

这篇文章是关于记忆的五个系列中的第一篇。我们将讨论诸如内存定义，如何管理，如何阅读工具输出等主题......本系列将讨论开发人员和系统管理员都会感兴趣的主题。虽然大多数规则应适用于大多数现代操作系统，但我们将更具体地讨论Linux和C编程语言。



我们不是第一个写关于记忆的人。特别是，我们想强调Ulricht Drepper的高质量论文：  [每位程序员应该了解的内存](http://www.akkadia.org/drepper/cpumemory.pdf)。

第一篇文章将提供内存的定义。它至少假定了诸如地址或过程等概念的基本知识。它还经常与科目，如系统调用和用户级和内核模式之间的区别，但是，你需要知道的是，你的进程（用户级）运行本身会谈硬件内核上面的是什么，而且交易系统调用让您的进程与内核进行通信，以请求更多资源。您可以通过阅读各自的手册页来获取有关系统调用的详细信息。

# 虚拟内存

在现代操作系统中，每个进程都存在于自己的内存分配空间中。操作系统不是将内存地址直接映射到硬件地址，而是充当硬件抽象层，并为每个进程创建虚拟内存空间。物理内存地址和虚拟地址之间的映射由CPU使用内核维护的每进程转换表完成（每次内核更改特定CPU内核上的运行进程时，它都会更改该CPU的转换表）。

虚拟内存有几个目的。首先，它允许进程隔离。userland中的进程只能将内存访问表示为虚拟内存中的地址。因此，它只能访问先前已在其自己的虚拟空间中映射的数据，因此无法访问其他进程的内存（除非明确共享）。

第二个目的是抽象硬件。内核可以自由更改虚拟地址映射到的物理地址。在实际需要之前，它还可以选择不为特定虚拟地址提供任何物理内存。此外，当它长时间没有使用并且系统缺少物理内存时，它可以将内存换成磁盘。这为内核提供了很大的自由，它唯一的限制是当程序读取内存时它实际上找到了它之前在那里写的东西。

第三个目的是为实际不在RAM中的事物提供地址的可能性。这是背后的原理`mmap`和映射文件。您可以为文件提供虚拟内存地址，以便可以像访问内存缓冲区一样访问它。这是一个非常有用的抽象，有助于保持代码非常简单，因为在64位系统上，您拥有巨大的虚拟空间，如果需要，您可以将整个硬盘映射到虚拟内存。

第四个目的是分享。由于内核知道在各种运行进程的虚拟空间中映射了什么进程，因此可以避免在内存中加载两次，并使使用相同资源的进程的虚拟地址指向同一物理内存（即使实际的虚拟地址）特定于每个过程）。共享的结果是内核使用写时复制（COW）：当两个进程使用相同的数据但其中一个修改它而另一个不允许看到更改时，内核将使数据修改后复制。最近，操作系统还获得了在几个地址空间中检测相同内存并自动使它们映射到同一物理内存的能力（将它们标记为COW）在Linux上，这称为[KSM（内核SamePage合并）](http://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM))。

## fork()

最着名的COW用例是`fork()`。在类Unix系统上，`fork()`系统调用是通过复制当前进程来创建进程的。当`fork()`返回时，这两个进程继续在完全相同的点，用同样打开的文件和相同的内存。感谢COW，`fork()`当你分叉时，不会复制进程的内存，只有被子进程修改的数据才会被复制到RAM中。由于大多数使用`fork()`后紧接着调用  `exec()`使整个虚拟内存寻址空间无效，因此COW机制避免了父进程内存的完全无用副本。

另一个副作用`fork()`是以很少的代价创建进程的（私有）内存的快照。如果你想在一个进程的内存上执行一些操作而不用冒险在你的脚下进行修改，并且不想添加一个昂贵且容易出错的锁定机制，只需分叉，做你的工作和沟通计算结果返回到父进程（通过返回代码，文件，共享内存，管道......）。

只要您的计算速度足够快，这样就可以非常好地工作，以便在父进程和子进程之间共享大部分内存。这也有助于保持代码简单，复杂性隐藏在内核的虚拟内存代码中，而不是隐藏在您的代码中。

## Page

虚拟内存分为页面。页面大小的大小由CPU强加，通常为4KiB 。这意味着内核中的内存管理是以页面的粒度完成的。当您需要新内存时，内核会为您提供一个或多个页面，当您释放内存时，您会释放一个或多个页面......每个更细粒度的API（例如`malloc`）都在用户区域中实现。

对于每个已分配的页面，内核保留一组权限：页面可以是可读，可写和/或可执行的（请注意，并非所有组合都是可能的）。在映射内存时或`mprotect()`之后使用系统调用设置这些权限。尚未分配的页面无法访问。当您尝试在页面上执行禁止操作时（例如，从没有读取权限的页面读取数据），您将触发（在Linux上）分段错误。作为旁注，您可能会看到由于分段错误具有页面的粒度，因此您可以执行不会导致段错误的缓冲区外访问。

# 内存类型

并非虚拟内存空间中分配的所有内存都相同。我们可以通过两个轴对它进行分类：第一个轴是内存是私有的（特定于该进程）还是共享的，第二个轴是内存是否是文件支持的（在这种情况下，它被称为匿名）。这将创建一个包含4个内存类的分类：

|          | 私有的                                                   | 共享                      |
| -------- | -------------------------------------------------------- | ------------------------- |
| 匿名     | **1**  1.stackmalloc() 2.mmap(ANON, PRIVATE) 3.brk()/sbrk() | **2** 1.mmap(ANON, SHARED) |
| 文件支持 | **3** 1.mmap(fd, PRIVATE) 2.binary/shared 3.libraries          | **4** 1.1mmap(fd, SHARED)    |

## 私有内存

正如其名称所述，私有内存是特定于进程的内存。您在程序中处理的大部分内存实际上都是私有内存。

由于私有内存中所做的更改对其他进程不可见，因此它可以进行写时复制。作为副作用，这意味着即使内存是私有的，多个进程也可能共享相同的物理内存来存储数据。特别是，二进制文件和共享库就是这种情况。一个常见的误解是KDE占用了大量的RAM，因为每个进程都加载了Qt和KDElib，但是，由于COW机制，所有进程都将使用完全相同的物理内存来存储这些库的只读部分。

在文件支持的私有内存的情况下，进程所做的更改不会写回到基础文件，但是对该文件所做的更改可能会也可能不会对进程可用。

## 共享内存

共享内存是为进程间通信而设计的。它只能通过使用正确的`mmap()`呼叫或专用呼叫（`shm*`）明确请求它来创建。当进程在共享内存中写入时，映射相同内存的所有进程都会看到修改。

如果内存是文件支持的，则映射文件的任何进程都将看到文件中的更改，因为这些更改是通过文件本身传播的。

## 匿名内存

匿名内存纯粹是在RAM中。但是，内核实际上不会在实际写入之前将该内存映射到物理地址。因此，匿名内存在实际使用之前不会对内核施加任何压力。这允许进程在其虚拟内存地址空间中“保留”大量内存而不使用RAM。因此，内核允许您保留比实际可用内存更多的内存。此行为通常被称为*过度提交*  （或内存过量使用）。

## 文件支持和交换

当内存映射由文件支持时，数据将从磁盘加载。大多数情况下，它是按需加载的，但是，您可以向内核提供提示，以便它可以在读取之前预取内存。当你知道你有一个特定的访问模式（主要是顺序访问）时，这有助于保持你的程序活泼。为了避免使用太多的RAM，您还可以告诉内核您不必关心RAM中的页面而不取消映射内存。所有这些都是使用`madvise()`系统调用完成的。

当系统没有物理内存时，内核会尝试将一些数据从RAM移动到磁盘。如果内存是文件支持和共享的，这很容易。由于文件是数据的来源，它只是从RAM中删除，然后在下次读取时，它将从文件中加载。

内核还可以选择从RAM中删除匿名/私有内存。在这种情况下，数据写在磁盘上的特定位置。据说它被换掉了。在Linux上，交换通常存储在特定分区中，在其他系统上，这可以是特定文件。然后，它的工作方式与文件支持的内存相同：当它被访问时，它从磁盘读取并重新加载到RAM中。

由于使用了虚拟寻址空间，交换页面进出流程对于进程来说是完全透明的......但是，不是由磁盘I / O引起的延迟。

# 下一页：常驻内存和工具

我们在这里介绍了一些关于记忆的重要概念。虽然我们谈了几次关于物理内存和与保留地址空间的区别，但我们避免处理过程的实际内存压力。我们将讨论该主题并描述一些工具，让您[在下一篇文章中](https://techtalk.intersec.com/2013/07/memory-part-2-understanding-process-memory/)了解进程的内存消耗。